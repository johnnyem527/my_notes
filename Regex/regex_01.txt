1. match
    匹配string 开头，成功返回Match object, 失败返回None，只匹配一个。
   search
    在string中进行搜索，成功返回Match object, 失败返回None, 只匹配一个。
   findall
    在string中查找所有 匹配成功的组, 即用括号括起来的部分。返回list对象，每个list item是由每个匹配的所有组组成的list。
   finditer
    在string中查找所有 匹配成功的字符串, 返回iterator，每个item是一个Match object。

2. 通用字符
        \w  匹配任意一个字母，数字或下划线
        \W  
        \d  匹配任意一个十进制数
        \D
        \s  匹配任意一个空白字符
        \S

3. [^xyz]代表除了中括号里面的原子均可以匹配

4. 元字符
    任意匹配元字符：
        .   匹配除换行符以外的任意字符
    边界限制元字符：
        ^   匹配字符串的开始位置
        $   匹配字符串的结束为止
    限定符：
        *   匹配0次，1次或多次前面的原子
        ?   匹配0次或1次前面的原子
        +   匹配1次或多次前面的原子
        {n} 前面的原子恰好出现n次
        {n,}    至少出现n次
        {n,m}   至少出现n次，至多出现m次
    |       模式选择符
    ()      模式单元符，将一些原子组合成一个大原子使用

5. 模式修正（用于第三个参数flag）
    I   匹配时忽略大小写
    M   多行匹配
    L   做本地化识别匹配
    U   根据Unicode字符集解析字符
    S   让.匹配包括换行符，即用了该模式修正后，“.”匹配就可以匹配任意的字符了

6. 贪婪模式： .*
   懒惰模式:  .*?

7. ?: 是 不想被捕获的时候使用 可以提高程序执行速度, 比如 ([a-z][0-9])+  
    这个正则表达式里  (  ) 里面的内容被捕获了， 反向引用的时候可以用上 。
    一般正则替换的时候用的多  像UBB代码 
    但是 如果写成  (?:[a-z][0-9])+   
    跟上面 正则表达式 整体匹配是一样的  就是 不会捕获 ( )里内容了。
    也就是不能使用 反向引用
    如果还是不太理解， 那就先了解一下 反向引用吧。

8. $        匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n' 或 ‘\r'。要匹配 $ 字符本身，请使用 \$。
  ( )       标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
   *        匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
   +        匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
   .        匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。
  [ ]       标记一个中括号表达式的开始。要匹配 [，请使用 \[。
   ?        匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
   \        将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n' 匹配字符 ‘n'。'\n' 匹配换行符。序列 ‘\\' 匹配 “\”，而 ‘\(' 则匹配 “(”。
   ^        匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
  { }       标记限定符表达式的开始。要匹配 {，请使用 \{。
   |        指明两项之间的一个选择。要匹配 |，请使用 \|。

9. 两个字符串之间的值不夹杂这两个字符串本身: BLA(?:(?!BLA|LOOK).)*?LOOK